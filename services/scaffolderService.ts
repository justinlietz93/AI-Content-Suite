



import type { ProgressUpdate, ScaffolderOutput, ScaffolderSettings, ScaffoldPlan, ScaffoldTreeItem } from '../types';
import { generateText } from './geminiService';
// FIX: Corrected import path for scaffolder prompts
import { SCAFFOLDER_PLANNING_PROMPT_TEMPLATE, SCAFFOLDER_FILE_PROMPT_GENERATION_TEMPLATE } from '../prompts/scaffolder/index';
import { MAX_CONTENT_CHAR_SIZE } from '../constants';
import { processTranscript } from './summarizationService';
import { cleanAndParseJson } from '../utils';

const generateScriptFromPlan = (plan: ScaffoldPlan, settings: ScaffolderSettings): string => {
    const scriptLang = settings.language;
    let script = '';

    if (scriptLang === 'bash') {
        script += '#!/bin/bash\n';
        script += '# Auto-generated by AI Content Suite Project Scaffolder\n\n';
        script += 'set -e\n\n';

        const dirs = new Set<string>();
        plan.tree.forEach(item => {
            const dir = item.path.substring(0, item.path.lastIndexOf('/'));
            if (dir) dirs.add(dir);
        });

        if (dirs.size > 0) {
            script += 'echo "Creating directories..."\n';
            dirs.forEach(dir => {
                script += `mkdir -p "${dir}"\n`;
            });
            script += '\n';
        }
        
        script += 'echo "Creating file prompts..."\n';
        plan.tree.forEach(item => {
            // Using a quoted HEREDOC delimiter prevents shell expansion inside the block
            script += `cat <<'EOF' > "${item.path}"\n`;
            script += item.prompt;
            script += '\nEOF\n\n';
        });

    } else if (scriptLang === 'python') {
        script += '#!/usr/bin/env python3\n';
        script += '# Auto-generated by AI Content Suite Project Scaffolder\n\n';
        script += 'import os\n\n';

        const dirs = new Set<string>();
        plan.tree.forEach(item => {
            // FIX: Replaced non-existent 'os' module with browser-compatible string manipulation.
            const dir = item.path.substring(0, item.path.lastIndexOf('/'));
            if (dir) dirs.add(dir);
        });

        if (dirs.size > 0) {
            script += 'print("Creating directories...")\n';
            dirs.forEach(dir => {
                script += `os.makedirs("${dir}", exist_ok=True)\n`;
            });
            script += '\n';
        }

        script += 'print("Creating file prompts...")\n';
        plan.tree.forEach(item => {
            // Using triple-quoted strings for file content
            script += `with open("${item.path}", "w", encoding="utf-8") as f:\n`;
            script += `    f.write(f"""${item.prompt}""")\n\n`;
        });
    }

    script += 'echo "Scaffolding complete!"\n';
    return script;
};

export const processScaffoldingRequest = async (
    prompt: string,
    settings: ScaffolderSettings,
    fileParts: any[], // For potential future context from files
    onProgress: (update: ProgressUpdate) => void,
    signal?: AbortSignal,
): Promise<ScaffolderOutput> => {
    const checkForCancellation = () => {
        if (signal?.aborted) {
            throw new DOMException('Aborted by user', 'AbortError');
        }
    };

    const fileContent = (fileParts || []).map(p => p.text || '').join('\n\n');
    let finalPrompt = [prompt, fileContent].join('\n\n').trim();

    if (!finalPrompt) {
        throw new Error("Scaffolder prompt is empty.");
    }
    
    checkForCancellation();
    
    if (finalPrompt.length > MAX_CONTENT_CHAR_SIZE) {
        onProgress({
            stage: 'Preprocessing Input',
            percentage: 5,
            message: 'Input content is very large. Summarizing...',
            thinkingHint: 'Condensing context for the architect...'
        });
        const summaryOutput = await processTranscript(finalPrompt, (p) => onProgress({ ...p, stage: 'Preprocessing Input' }), true, 'default', signal);
        finalPrompt = `The user's large request has been summarized:\n\n${summaryOutput.finalSummary}`;
    }

    // --- PHASE 1: PLANNING ---
    checkForCancellation();
    onProgress({
        stage: 'Planning Architecture',
        percentage: 15,
        message: 'AI architect is designing the project structure...',
        thinkingHint: 'This initial plan forms the blueprint for the scaffold.'
    });

    const planningPrompt = SCAFFOLDER_PLANNING_PROMPT_TEMPLATE(finalPrompt, settings);
    const planningResultRaw = await generateText(planningPrompt, { maxOutputTokens: 32768 }, signal);
    
    let plan: ScaffoldPlan;
    try {
        plan = cleanAndParseJson<ScaffoldPlan>(planningResultRaw);
    } catch(e) {
        console.error("Failed to parse scaffold plan from AI:", e);
        const error = new Error(`Failed to parse the project plan from the AI. The data might be malformed.`);
        (error as any).details = (e as any).details || planningResultRaw;
        throw error;
    }

    if (!plan || !plan.tree || plan.tree.length === 0) {
        throw new Error("The AI architect failed to generate a valid file tree for the project.");
    }

    // --- PHASE 2: ITERATIVE PROMPT GENERATION ---
    const totalFiles = plan.tree.length;
    const generationStartPercentage = 25;
    const generationRange = 65; // 25% -> 90%

    for (let i = 0; i < totalFiles; i++) {
        checkForCancellation();
        const fileItem = plan.tree[i];
        const progress = generationStartPercentage + ((i + 1) / totalFiles) * generationRange;

        onProgress({
            stage: 'Generating File Prompts',
            percentage: progress,
            message: `[${i + 1}/${totalFiles}] Generating prompt for: ${fileItem.path}`,
            current: i + 1,
            total: totalFiles,
        });

        const filePromptGen = SCAFFOLDER_FILE_PROMPT_GENERATION_TEMPLATE(plan.project, fileItem);
        const generatedPrompt = await generateText(filePromptGen, { maxOutputTokens: 4096 }, signal);
        
        // Update the plan in place
        plan.tree[i].prompt = generatedPrompt.trim();
    }

    // --- PHASE 3: SCRIPT SYNTHESIS ---
    checkForCancellation();
    onProgress({
        stage: 'Synthesizing Script',
        percentage: 95,
        message: 'Assembling the final scaffold script locally...',
    });

    const scaffoldScript = generateScriptFromPlan(plan, settings);

    onProgress({ stage: 'Completed', percentage: 100, message: 'Scaffolding process complete.' });
    
    return {
        scaffoldScript,
        scaffoldPlanJson: plan,
    };
};